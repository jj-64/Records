Headcount_80 = hcr80))
results
load("C:/Users/User/Documents/HSPE/DATA/DataProcessed/SumData.rda")
View(data)
colnames(data)
devtools::install_github("jj-64/HSPE")
library(HSPE)
HSPE::load(DATA/data)
HSPE::load(DATA/data)
HSPE::load(DATA/SumData)
HSPE::load(DATA/SumData.rda)
library(HSPE)
devtools::install_github("jj-64/HSPE", upgrade = "ask")
detach("package:HSPE", unload = TRUE)
devtools::install_github("jj-64/HSPE", upgrade = "ask")
library(HSPE)
load(HSPE::SumData)
data("SumData")
colnames(data)
head(data)
head(data,1)
glimpse(data)
load("C:/Users/User/Documents/HSPE/data/HC_limited_data.rda")
View(HC_limited_data)
head(HC_limited_data,1)
load("C:/Users/User/Documents/HSPE/data/CI_limited_data.rda")
View(CI_limited_data)
head(CI_limited_data,1)
load("C:/Users/User/Documents/HSPE/data/Param_limited_data.rda")
head(Param_limited_data,1)
View(data)
library(HSPE)
data(Param_limited_data)
??Param_limited_data
?Param_limited_data
??Param_limited_data.rda
??Param_limited_data.R
describe(Param_limited_data)
library(ggplot2)
library(dplyr)
library(tidyr)
data(HC_limited_data)
HC_long <- HC_limited_data %>%
pivot_longer(cols = c(Observed, FISK_H, LN_H, NP_H),
names_to = "Model",
values_to = "Headcount")
ggplot(HC_long, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 2) +
geom_line() +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
View(HC_long)
View(HC_limited_data)
View(HC_long)
ggplot(HC_long, aes(x = Country, y = Headcount, color = Model, group = Model, alpha = 0.2)) +
geom_point(size = 2) +
geom_line() +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long, aes(x = Country, y = Headcount, color = Model, group = Model, alpha = 0.2)) +
geom_point(size = 2, alpha=0.2) +
geom_line() +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long, aes(x = Country, y = Headcount, color = Model, group = Model), alpha=0.2) +
geom_point(size = 2) +
geom_line() +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 2, alpha=0.5) +
geom_line() +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 2, alpha=0.5) +
geom_line(alpha=0.5) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 2, alpha=0.9) +
geom_line(alpha=0.9) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 2, alpha=0.1) +
geom_line(alpha=0.1) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 1, alpha=0.2) +
geom_line(alpha=0.2) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long[1:50,], aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 1, alpha=0.2) +
geom_line(alpha=0.2) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
HC_long2 = HC_long[1:50,]
ggplot(HC_long2, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 1, alpha=0.2) +
geom_line(alpha=0.2) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
View(HC_long2)
HC_long2 = HC_long[1:1000,]
ggplot(HC_long2, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 1, alpha=0.2) +
geom_line(alpha=0.2) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
HC_long2 = HC_long[1:50,]
ggplot(HC_long2, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 1, alpha=0.9) +
geom_line(alpha=0.9) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long2, aes(x = Country, y = Headcount, color = Model, group = Model)) +
geom_point(size = 3, alpha=0.9) +
geom_line(alpha=0.9) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long2, aes(x = Country, y = Headcount*100, color = Model, group = Model)) +
geom_point(size = 1.5, alpha=0.5) +
geom_line(alpha=0.5) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount (%)") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
ggplot(HC_long, aes(x = Country, y = Headcount*100, color = Model, group = Model)) +
geom_point(size = 1.5, alpha=0.5) +
#geom_line(alpha=0.5) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount (%)") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
View(HC_limited_data)
11784/3
HC_limited_data$threshold = rep(c(0.2,0.5,0.8), 3928)
HC_limited_data$threshold
HC_limited_data$threshold = rep(c(0.2,0.5,0.8), 3928)
HC_limited_data$threshold = rep(c(0.2,0.5,0.8), 2946/3)
HC_long <- HC_limited_data %>%
pivot_longer(cols = c(Observed, FISK_H, LN_H, NP_H),
names_to = "Model",
values_to = "Headcount")
View(HC_long)
HC_long = subset(HC_long, threshold == 0.2)
ggplot(HC_long, aes(x = Country, y = Headcount*100, color = Model, group = Model)) +
geom_point(size = 1.5, alpha=0.5) +
geom_line(alpha=0.5) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount (%)") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
HC_long <- HC_limited_data %>%
pivot_longer(cols = c(Observed, FISK_H, LN_H, NP_H),
names_to = "Model",
values_to = "Headcount")
## if only for certain poverty line threshold
HC_long2 = subset(HC_long, threshold == 0.2)
ggplot(HC_long2, aes(x = Country, y = Headcount*100, color = Model, group = Model)) +
geom_point(size = 1.5, alpha=0.5) +
geom_line(alpha=0.5) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount (%)") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
## if only for certain poverty line threshold
HC_long2 = subset(HC_long, threshold == 0.8)
ggplot(HC_long2, aes(x = Country, y = Headcount*100, color = Model, group = Model)) +
geom_point(size = 1.5, alpha=0.5) +
geom_line(alpha=0.5) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount (%)") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
## if only for certain poverty line threshold
HC_long2 = subset(HC_long, threshold == 0.5)
ggplot(HC_long2, aes(x = Country, y = Headcount*100, color = Model, group = Model)) +
geom_point(size = 1.5, alpha=0.5) +
geom_line(alpha=0.5) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount (%)") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
## if only for certain poverty line threshold
HC_long2 = subset(HC_long, threshold == 0.5)
ggplot(HC_long, aes(x = Country, y = Headcount*100, color = Model, group = Model)) +
geom_point(size = 1.5, alpha=0.5) +
geom_line(alpha=0.5) +
theme_minimal(base_size = 14) +
labs(title = "Poverty Headcount Comparison: Observed vs. Fitted Models",
x = "Country",
y = "Poverty Headcount (%)") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
data(CI_limited_data)
CI_long <- CI_limited_data %>%
pivot_longer(
cols = ends_with("_lower") | ends_with("_upper"),
names_to = c("Model", ".value"),
names_pattern = "(.+)_(lower|upper)"
)
ggplot(CI_long, aes(x = threshold, color = Model)) +
geom_ribbon(aes(ymin = lower, ymax = upper, fill = Model),
alpha = 0.25, color = NA) +
geom_line(aes(y = (lower + upper) / 2), size = 1.2) +
facet_wrap(~ Country) +
theme_minimal(base_size = 14) +
labs(title = "95% Confidence Intervals for Poverty Headcounts",
x = "Poverty Threshold (fraction of mean income)",
y = "Headcount") +
guides(fill = guide_legend(title = "Model"),
color = guide_legend(title = "Model"))
gc()
iid_Norm <- lapply(1:5, function(i) {
data.frame(
values = rnorm(length_series),
timepoint = 1:length_series,
id = paste0("IID_", i),
process = "IID"
)
})
iid_Norm
iid_Norm <- lapply(1:5, function(i) {
data.frame(
values = rnorm(length_series),
timepoint = 1:length_series,
id = paste0("IID_", i),
process = "IID"
)
})
iid_Norm
gc()
iid_Norm <- lapply(1:5, function(i) {
data.frame(
values = rnorm(100),
timepoint = 1:100,
id = paste0("IID_", i),
process = "IID"
)
})
sim_data = do.call(rbind, c(iid_Norm))
View(sim_data)
# ----- 0. Setup ----------------------------------------------------------------
set.seed(12345)
required_packages <- c(
"tidyverse", "forecast", "e1071", "randomForest", "caret", "xgboost",
"pROC", "glmnet", "nnet", "kernlab", "MASS", "car", "signal", "moments"
)
install_if_missing <- function(pkgs) {
for (p in pkgs) {
if (!suppressWarnings(require(p, character.only = TRUE))) {
install.packages(p, dependencies = TRUE)
library(p, character.only = TRUE)
}
}
}
install_if_missing(required_packages)
# Load libraries
lapply(required_packages, require, character.only = TRUE)
generate_series <- function(generator, ## function:the function generating the series
series_args=list(), ## arguments of the generator function other than "T" and the "param_name" we are simulating
n_arg="T",
T_val = 200) {
## --- Helper: Generate series under true model H0
args <- series_args
args[[n_arg]] <- T_val   # could be "T" or "n"
X <- do.call(generator, args)
return(X)
}
## ---- Helper function: Generate many series and keep labels
#n_per_model: number of series generated for each model to have a balanced database
generate_series_multiple <- function(n_per_model = 50, T_val = 200) {
all_series <- list()
labels <- c()
series_id <- c()
## DTRW series
for (i in 1:n_per_model) {
s <- generate_series(DTRW_series,
series_args = list(dist = "norm", mean = 0, sd = 1),
T_val = T_val)
all_series[[length(all_series) + 1]] <- s
labels <- c(labels, "DTRW")
series_id <- c(series_id, paste0("DTRW_",i))
}
## LDM series
for (i in 1:n_per_model) {
s <- generate_series(LDM_series,
series_args = list(theta = runif(1,0.1,0.3), dist = "frechet", shape=1, scale=2),
T_val = T_val)
all_series[[length(all_series) + 1]] <- s
labels <- c(labels, "LDM")
series_id <- c(series_id, paste0("LDM_",i))
}
## YNM series
for (i in 1:n_per_model) {
s <- generate_series(YNM_series,
series_args = list(gamma = runif(1,1.1,1.5), dist = "frechet", shape=1,scale=5),
T_val = T_val)
all_series[[length(all_series) + 1]] <- s
labels <- c(labels, "YNM")
series_id <- c(series_id, paste0("YNM_",i))
}
## iid series
for (i in 1:n_per_model) {
s <- rnorm(T_val, mean=0, sd = 1)
all_series[[length(all_series) + 1]] <- s
labels <- c(labels, "Classical")
series_id <- c(series_id, paste0("Classical_",i))
}
return(list(series = all_series, labels = labels, series_id = series_id))
}
# Helper: `%||%` operator - return left if not null else right
`%||%` <- function(a, b) if (!is.null(a)) a else b
extract_features <- function(series) {
s <- as.numeric(series)
n <- length(s)
if (n < 10) stop("Series too short for stable features")
# Basic stats
ave = mean(s)
cv <- sd(s)/mean(s)
std <- sd(s)
med <- median(s)
iqrv <- IQR(s)
skew <- ifelse(length(na.omit(s))>2, moments::skewness(s), NA)
kurt <- ifelse(length(na.omit(s))>3, moments::kurtosis(s), NA) # excess? moments::kurtosis returns fisher or pearson? okay
# extremes
minv <- min(s)
maxv <- max(s)
rng <- maxv - minv
# record info
rec_high_idx <- rec_times(s)   # Foreword record highs
rec_high_values <- rec_values(s)
rec_high_idx_back <- rec_times(rev(s))  # Backward record highs
rec_high_values_back <- rec_values(rev(s))
#rec_low_idx <- rec_times(-s)   # Foreword record lows
#rec_low_values <- rec_values(-s)
#rec_low_idx_back <- rec_times(rev(-s))  # Backward record lows
#rec_low_values_back <- rec_values(rev(-s))
rec_high_rate <- length(rec_high_idx)/n
rec_high_back_rate <- length(rec_high_idx_back)/n
#rec_low_rate <- length(rec_low_idx)/n
#rec_low_back_rate <- length(rec_low_idx_back)/n
# inter-record intervals (for highs and lows, forward and backward)
rec_high_gap <- if (length(rec_high_idx) >= 2) rec_gaps(series) else NA
#rec_low_gap <-  if (length(rec_low_idx) >= 2) rec_gaps(-series) else NA
rec_high_gap_back <- if (length(rec_high_idx_back) >= 2) rec_gaps(rev(series)) else NA
#rec_low_gap_back <-  if (length(rec_low_idx_back) >= 2) rec_gaps(-rev(series)) else NA
rec_high_gap_median <- if (!all(is.na(rec_high_gap))) median(rec_high_gap, na.rm = TRUE) else NA
#rec_low_gap_median <-  if (!all(is.na(rec_low_gap))) median(rec_low_gap, na.rm = TRUE) else NA
rec_high_gap_back_median <- if (!all(is.na(rec_high_gap_back))) median(rec_high_gap_back, na.rm = TRUE) else NA
#rec_low_gap_back_median <-  if (!all(is.na(rec_low_gap_back))) median(rec_low_gap_back, na.rm = TRUE) else NA
rec_high_gap_sd <- if (!all(is.na(rec_high_gap))) sd(rec_high_gap, na.rm = TRUE) else NA
#rec_low_gap_sd <-  if (!all(is.na(rec_low_gap))) sd(rec_low_gap, na.rm = TRUE) else NA
rec_high_gap_back_sd <- if (!all(is.na(rec_high_gap_back))) sd(rec_high_gap_back, na.rm = TRUE) else NA
#rec_low_gap_back_sd <-  if (!all(is.na(rec_low_gap_back))) sd(rec_low_gap_back, na.rm = TRUE) else NA
# Entropy of record indicator
p <- mean(is_rec(s))
entropy <- if (p > 0 && p < 1) {
- (p * log2(p) + (1 - p) * log2(1 - p))
} else {
0
}
# trend: linear slope and p-value
time <- seq_len(n)
lmfit <- lm(s ~ time)
slope <- as.numeric(coef(lmfit)[2])
slope_pval <- summary(lmfit)$coefficients[2, 4]
# Mann-Kendall proxy: Kendall correlation between time and series
kendall_tau <- cor(time, s, method = "kendall")
# autocorrelation
acf_vals <- acf(s, lag.max = 5, plot = FALSE)$acf
acf1 <- ifelse(length(acf_vals) >= 2, acf_vals[2], NA)
acf2 <- ifelse(length(acf_vals) >= 3, acf_vals[3], NA)
# spectral: dominant frequency via periodogram
spec <- stats::spec.pgram(s, plot = FALSE, taper = 0)
if (length(spec$spec) > 0) {
dom_idx <- which.max(spec$spec)
dom_freq <- spec$freq[dom_idx]
dom_power <- spec$spec[dom_idx]
} else {
dom_freq <- NA; dom_power <- NA
}
# crossing and peak counts
cross_mean <- sum(diff(s > ave) != 0)  # number of times series crosses its mean
prop_pos <- mean(s > mean(rec_values(s)))
extreme_2sd <- sum(abs(s - ave) > 2 * std) / n
extreme_3sd <- sum(abs(s - ave) > 3 * std) / n
# variability of first differences
diffs <- diff(s)
diff_mean <- mean(diffs)
diff_sd <- sd(diffs)
diff_skew <- ifelse(length(diffs) > 2, moments::skewness(diffs), NA)
# adf-like: use ndiffs from forecast to estimate number of differences needed (proxy for non-stationarity)
ndiff_needed <- tryCatch(forecast::ndiffs(s), error = function(e) NA)
ljung <- tryCatch(Box.test(s, lag = 10, type = "Ljung-Box"), error = function(e) list(statistic = NA, p.value = NA))
# proportion of positive first differences
prop_inc <- mean(diffs > 0)
# Turning points
diff_sign <- diff(sign(diff(s)))
turning_points <- sum(diff_sign != 0, na.rm = TRUE)
# Local extrema
local_maxima <- length(which(diff_sign == -2))/n
local_minima <- length(which(diff_sign == 2))/n
# feature vector
features <- c(
n = n,
mean = ave,
std = std,
median = med,
iqr = iqrv,
skewness = skew,
kurtosis = kurt,
min = minv,
max = maxv,
range = rng,
rec_high_rate = rec_high_rate,
#rec_low_rate = rec_low_rate,
rec_high_back_rate = rec_high_back_rate,
#rec_low_back_rate = rec_low_back_rate,
rec_high_gap_median = rec_high_gap_median,
#rec_low_gap_median = rec_low_gap_median,
rec_high_gap_back_median = rec_high_gap_back_median,
#rec_low_gap_back_median = rec_high_gap_back_median,
rec_high_gap_sd = rec_high_gap_sd,
#rec_low_gap_sd = rec_low_gap_sd,
rec_high_gap_back_sd = rec_high_gap_back_sd,
#rec_low_gap_back_sd = rec_high_gap_back_sd,
entropy = entropy,
slope = slope,
slope_p = slope_pval,
kendall_tau = kendall_tau,
acf1 = acf1,
acf2 = acf2,
#pacf1 = pacf1,
dom_freq = dom_freq,
dom_power = dom_power,
cross_mean = cross_mean,
prop_pos = prop_pos,
extreme_2sd = extreme_2sd,
extreme_3sd = extreme_3sd,
diff_mean = diff_mean,
diff_sd = diff_sd,
diff_skew = diff_skew,
ndiff_needed = ndiff_needed,
ljung = ljung$p.value,
prop_inc = prop_inc,
turning_points = turning_points,
local_minima = local_minima,
local_maxima = local_maxima
)
# make numeric and named
#as.numeric(features) %>% setNames(names(features))
return(features)
}
## Generate feature_matrix (this may take a few minutes depending on size)
cat("Generating feature_matrix (this may take a bit)...\n")
## Generate series (this may take a few minutes depending on size)
cat("Generating multiple series (this may take a bit)...\n")
sim_data <- generate_series_multiple(n_per_model = 50, T_val = 100)
cat("Done generating.\n")
sim_data$series
